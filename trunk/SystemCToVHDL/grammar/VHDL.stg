group simple;


file(entity) ::= <<
<entity>
>>

entity(name, ports, signals, enums, variables,process, structure, instances, functions) ::= <<
entity <name> is
	port(
 		<ports; separator="; \n">
	); 
end <name>;

architecture systemc of <name> is
	<enums; separator="; \n"> 
	<variables.keys:{k|variable <variables.(k); separator=", "> : <k>  }; separator="; \n">
	<signals; separator="; \n">;
	begin
	
	<structure.keys:{k| <k> : <instances.(k)>
	port map { 
		<structure.(k); separator=", \n">
	}; }; separator="\n">
	
	<process.keys:{k|<process.(k)>
	 <functions.(k)>  }; separator="\n">;
	
end systemc ;
>>

port(name, type) ::=<<
<name; separator=", "> : <type>
>>

clock_type() ::= "in std_logic"

input_type(type) ::= "in <type>"

output_type(type) ::= "out <type>"

inout_type(type) ::= "inout <type>"

signal(name, type) ::=<<
signal <name; separator=", "> : <type>
>>


logic_vector(size) ::= <<
std_logic_vector(<size; format="decrement"> downto 0 )
>>

logic() ::= "std_logic"
bool() ::= "std_logic"

custom(name) ::= "<name>"

dummy(val) ::= "<val>"

process(name, sensitive) ::= <<
-- <name>
process(<sensitive; separator=", ">)
>>

func_body(declarations, operations ) ::=<<
<declarations.keys:{k|variable <declarations.(k); separator=", "> : <k>  }; separator="; \n">
begin
	<operations; separator="\n">
end process;
>>

signal_assignement(dest, source)::= <<
<dest> \<= <source; format="toVHDL"> ;
>>

enum(name, members) ::= <<
TYPE <name> IS (<members; format="toUpper", separator=", ">);
>>

link(source, dest) ::= "<source> => <dest>"

actor_inst(type, name) ::="<name> : <type>"

method(name, args) ::= ".<name>(<args>)"

range(from, to) ::= "(<from> downto <to>)"
concat(left, right) ::= "(<left> & <right>)"
var_value(not, var, methods) ::=<<
<if(not)>NOT <endif><var; format="toVHDL"><methods>
>>
array_value(var, index, methods) ::="<var>(<index>)<methods>"
expression(head, op, tail) ::= "<head> <op> <tail>"

if_construct(condition, elts, alternatives) ::= <<
if <condition> then
	<elts; separator=" \n">
<alternatives; separator="\n">
end if ;
>>

elsif_construct(condition, elts) ::= <<
elsif <condition> then
	<elts; separator=" \n">
>>

else_construct( elts) ::= <<
else
	<elts; separator=" \n">
>>

conditions(vals, ops) ::= <<
<if(!ops)>
<first(vals)>
<else>
<first(vals)> <first(ops)> <conditions(vals = rest(vals), ops = rest(ops))>
<endif>
>>




test(neg, l, r, operator)::=<<
<if(neg)>NOT<endif> <l; format="toVHDL"> <if(operator)><operator; format="toVHDL"> <r; format="toVHDL"> <else>= '1' <endif>
>>

var_assign(var, val) ::=<<
<var> := <val>;
>>

vhdl_or() ::= "OR"
vhdl_and() ::= "AND"

case(val , cont )::=<<
<if(val)>
when <val> => 
	<cont; separator="\n">
<else>
when others => 
	<cont; separator="\n">
<endif>

>>

switch(cases , var ) ::= <<
case <var> is
	<cases; separator="\n">
end case ;
>>

func_call(name, args)::=<<
<if(name)>
<name>(<args; separator=", ">)
<else>
<args; separator=" & ">
<endif>
>>


enclosed(val) ::= "(<val>)"
