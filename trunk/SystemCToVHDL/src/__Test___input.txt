
#include "systemc.h"
#include "i2c_master.h"
#include "register_rom.h"


#define NB_REGS	255
#define OV7670_I2C_ADDR 0x42

/* je suis 
*
* un commentaire */

//un autre commentaire

SC_MODULE (camera_interface) {

	sc_in_clk clock;
	sc_in_clk pclock;
	sc_in_clk i2c_clk;
	sc_in<bool> arazb;
	sc_inout_rv<8> pixel_data;
	sc_inout<sc_lv<8> > y_data;
	sc_inout<sc_lv<8> > u_data;
	sc_inout<sc_lv<8> > v_data;
	sc_inout_resolved scl;
	sc_inout_resolved sda;
	sc_out<bool> new_pix, new_line, new_frame;
	sc_in<bool> pxclk, href, vsync;

	sc_signal<sc_lv<8> > i2c_data;
	sc_signal<sc_lv<16> > reg_data;
	sc_signal<sc_lv<7> > i2c_addr;
	sc_signal<bool> send;
	sc_signal<bool> rcv;
	sc_signal<bool> dispo;
	sc_signal<bool> ack_byte;

	enum pixel_state {
		Y1, U1, Y2, V1
	};

	sc_signal<pixel_state> pix_state;

	enum registers_state {
		init, send_addr, send_data, next_reg, stop
	};

	sc_signal<registers_state> reg_state;

	sc_signal<sc_lv<8> > y1_delay, u_delay, v_delay, y2_delay;

	sc_signal<sc_logic> sccb_wr, sccb_rd;
	sc_signal<bool> valid_pixel;
	sc_signal<sc_uint<8> > reg_addr;
	i2c_master i2c_master0;
	register_rom register_rom0;

	void sccb_interface();
	void pixel_interface();

	SC_CTOR(camera_interface) :
			i2c_master0("i2c_master0"), register_rom0("register_rom0") {
		i2c_master0.clock(i2c_clk);
		i2c_master0.arazb(arazb);
		i2c_master0.sda(sda);
		i2c_master0.scl(scl);
		i2c_master0.data(i2c_data);
		i2c_master0.slave_addr(i2c_addr);
		i2c_master0.send(send);
		i2c_master0.rcv(rcv);
		i2c_master0.dispo(dispo);
		i2c_master0.ack_byte(ack_byte);

		register_rom0.addr(reg_addr);
		register_rom0.data(reg_data);

		SC_METHOD(sccb_interface);
		sensitive << dispo;
		sensitive << ack_byte;

		SC_METHOD(pixel_interface);
		sensitive << pclock.pos();
	}

};

unsigned int regs[256];

void camera_interface::sccb_interface() {
	i2c_addr.write(OV7670_I2C_ADDR);
	switch (reg_state.read()) {
	case init:
		if (dispo.read()) {
			send.write(1);
			i2c_data.write(reg_data.read().range(15, 8));
			reg_state.write(send_addr);
		}
		break;
	case send_addr:
		if (ack_byte.read()) {
			cout << "Writing to addr " << reg_data.read().range(15, 8) << " data "<< reg_data.read().range(7, 0)<< endl;
			send.write(1);
			i2c_data.write(reg_data.read().range(7, 0));
			reg_state.write(send_data);
		}
		break;
	case send_data:
		if (ack_byte.read()) {
			send.write(0);
			reg_state.write(next_reg);
			reg_addr.write(reg_addr.read() + 1);
		}
		break;
	case next_reg:
		cout << "Next address is " << reg_addr.read() << endl;
		send.write(0);
		if ((! ack_byte.read()) && reg_data.read() != 0xFFFF && dispo.read() && reg_addr.read() < 255) {
			reg_state.write(send_addr);
			i2c_data.write(reg_data.read().range(15, 8));
			send.write(1);
		} else if (reg_addr.read() >= 255 || reg_data.read() == 0xFFFF) {
			reg_state.write(stop);
		}
		break;
	case stop:
		send.write(0);
		reg_state.write(stop);
		break;
	default:
		reg_state.write(init);
		break;
	}

}
void camera_interface::pixel_interface() {
	new_line.write(!href.read());
	new_frame.write(vsync.read());
	if (pclock.posedge()) {
		if (href.read() && !vsync.read() && pclock.read()) {
			switch (pix_state.read()) {
			case Y1:
				y2_delay.write(pixel_data.read());
				new_pix.write(valid_pixel.read());
				pix_state.write(U1);
				break;
			case U1:
				y_data.write(y1_delay.read());
				u_data.write(u_delay.read());
				v_data.write(v_delay.read());
				u_delay.write(pixel_data.read());
				new_pix.write(0);
				pix_state.write(Y2);
				break;
			case Y2:
				y1_delay.write(pixel_data.read());
				new_pix.write(valid_pixel.read());
				pix_state.write(V1);
				break;
			case V1:
				y_data.write(y2_delay.read());
				u_data.write(u_delay.read());
				v_data.write(pixel_data.read());
				v_delay.write(pixel_data.read());
				valid_pixel.write(1);
				new_pix.write(0);
				pix_state.write(Y1);
				break;
			default:
				pix_state.write(Y1);
				break;
			}
		} else if (!href.read() || vsync.read()) {
			pix_state.write(Y1);
			valid_pixel.write(0);
		}
	}

}

